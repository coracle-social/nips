NIP-89
======

Recommended Application Handlers
--------------------------------

`draft` `optional`

This NIP describes a way to discover different types of applications that can handle unknown event-kinds.

## Rationale

Nostr's discoverability and transparent event interaction is one of its most interesting/novel mechanics.
This NIP provides a simple way for clients to discover applications that handle events of a specific kind to ensure smooth cross-client and cross-kind interactions.

## Overview

This NIP defines "application handlers", which are events intended to advertise support for a certain event kind. These handlers may be for several different types of nostr-related applications, including:

- `31990` for nostr clients
- `31991` for nostr DVMs
- `31992` for nostr relays

This NIP also defines a `kind:31989` recommendation event which allows users to endorse application handlers.

## Client Handler

A "client handler" is a `kind:31990` event which includes details about which event kinds are supported by a client, and how to send users to the application.

* `content` is an optional `metadata`-like stringified JSON object, as described in NIP-01. This content is useful when the pubkey creating the `kind:31990` is not an application. If `content` is empty, the `kind:0` of the pubkey should be used to display application information (e.g. name, picture, web, LUD16, etc.)
* One or more `k` tags indicate the event kind(s) that are supported by this client.
* One or more handler tags (`web|ios|android|<other>`) MUST be included, indicating url templates that other applications can use to redirect users to the client in question. The string `<bech32>` in a URL MUST be replaced by clients with the NIP-19-encoded entity that should be loaded by the application. An optional second argument indicates the type of NIP 19 entity expected.

```jsonc
{
  "kind": 31990,
  "pubkey": "<application-pubkey>",
  "content": "<optional-kind:0-style-metadata>",
  "tags": [
    ["d", 'EvAX3S1smP8'],
    ["k", 1],
    ["k", 20],
    ["web", "https://..../a/<bech32>", "nevent"],
    ["web", "https://..../p/<bech32>", "nprofile"],
    ["web", "https://..../e/<bech32>"],
    ["ios", ".../<bech32>"]
  ],
  // other fields...
}
```

## DVM Handler

A "DVM handler" is a `kind:31991` event which includes details about which event kinds are supported by a DVM, and how to send requests to the service.

* `content` is an optional `metadata`-like stringified JSON object, as described in NIP-01. This content is useful when the pubkey creating the `kind:31990` is not an application. If `content` is empty, the `kind:0` of the pubkey should be used to display application information (e.g. name, picture, web, LUD16, etc.)
* One or more `k` tags indicate the event kind(s) that are supported by this DVM.
* One or more `relay` tags MUST be included indicating relays that the DVM receives requests on.

Example:

```jsonc
{
  "kind": 31991,
  "pubkey": "<application-pubkey>",
  "content": "<optional-kind:0-style-metadata>",
  "tags": [
    ["d", 'lLrjDuVXfgk'],
    ["k", 5300],
    ["relay", "wss://my-dmv-relay.example.com/"],
    ["relay", "wss://my-other-dmv-relay.example.com/"]
  ],
  // other fields...
}
```

## Relay Handler

A "Relay handler" is a `kind:31992` event which includes details about how to reach the relay.

* `content` is an optional `metadata`-like stringified JSON object, as described in NIP-01. This content is useful when the pubkey creating the `kind:31990` is not an application. If `content` is empty, the `kind:0` of the pubkey should be used to display application information (e.g. name, picture, web, LUD16, etc.)
* One or more `r` tags MUST be included indicating urls that the relay is accessible on.

Example:

```jsonc
{
  "kind": 31991,
  "pubkey": "<application-pubkey>",
  "content": "<optional-kind:0-style-metadata>",
  "tags": [
    ["d", 'Ti2E8pDpt4k'],
    ["r", "wss://nostr.sovbit.host/"],
    ["r", "ws://sovbitgz5uqyh7jwcsudq4sspxlj4kbnurvd3xarkkx2use3k6rlibqd.onion/"],
    ["r", "gnunet://fs/ksk/gpl"]
  ],
  // other fields...
}
```

## Handler Recommendations

A "handler recommendation" is an event that indicates that a given application is a good fit for handling some nostr kind in a certain context.

- Its `d` tag MUST BE the supported event kind this event is recommending.
- One or more `a` tags indicate recommended apps by nostr address. A relay hint MUST be included. If the recommended application is a client, the third tag argument SHOULD be a platform string.

In order to recommend handlers for multiple kinds, users must publish multiple `kind:31989` events.

```jsonc
{
  "kind": 31989,
  "pubkey": <recommender-user-pubkey>,
  "tags": [
    ["d", <supported-event-kind>],
    ["a", "31990:app1-pubkey:<d-identifier>", "wss://relay1", "ios"],
    ["a", "31990:app2-pubkey:<d-identifier>", "wss://relay2", "web"],
    ["a", "31991:app2-pubkey:<d-identifier>", "wss://relay3"]
  ],
  // other fields...
}
```

## Example Flow

There are three actors to this workflow:

* A client that handles a specific event kind
  * Publishes `kind:31990`, detailing how apps should redirect to it
* User A, who recommends an app that handles a specific event kind
  * Publishes `kind:31989`
* User B, who seeks a recommendation for an app that handles a specific event kind
  * Queries for `kind:31989` and, based on results, queries for `kind:31990`

Let's say Alice has found a `kind:20` event in the wild, quoted in a kind 1 and her client doesn't render it except by showing its `alt` tag. In order to find recommendations from her social graph for clients that support `kind:20`, her client might send out a request with a filter something like this:

```jsonc
{
  "authors": [<alice's follow list>],
  "kinds": [31989],
  "#d": [20]
}
```

This will retrieve trusted recommendations for clients that support kind 20. One of them might look like this:

```
{
  "kind": 31989,
  "tags": [
    ["d", "20"],
    ["a", "31990:1743058db7078661b94aaf4286429d97ee5257d14a86d6bfa54cb0482b876fb0:Ebic0qwOQZ0", "wss://relay.example.com/", "web"]
  ],
  // other fields...
}
```

Alice's client can them retrieve the referenced handler from `wss://relay.example.com/` (or the address pubkey's 10002 write relays) using the following filter:

```
{
  "authors": ["1743058db7078661b94aaf4286429d97ee5257d14a86d6bfa54cb0482b876fb0"],
  "kinds": [31990],
  "#d": ["Ebic0qwOQZ0"]
}
```

This would turn up an application handler that might look something like this:

```
{
  "kind": 31990,
  "pubkey": "<application-pubkey>",
  "content": "<optional-kind:0-style-metadata>",
  "tags": [
    ["d", 'EvAX3S1smP8'],
    ["k", 20],
    ["web", "https://my-nostr-client.com/e/<bech32>"],
    ["ios", ".../<bech32>"]
  ],
  // other fields...
}
```

Alice's client can now show some indication that another client might be better suited to hande this event. She can then click a button (or something), and the client can fill out a template and redirect Alice. For example the `web` template might look like this:

```
https://my-nostr-client.com/e/nevent1qvzqqqqqzspzpq35r7yzkm4te5460u00jz4djcw0qa90zku7739qn7wj4ralhe4zqyvhwumn8ghj7urjv4kkjatd9ec8y6tdv9kzumn9wshsz9nhwden5te0wfjkccte9ekk7um5wgh8qatz9uq3wamnwvaz7tmjv4kxz7fwwpexjmtpdshxuet59uqzqu58spynxnvuxf75r6ayua69cpv02k8ehur3zplmt7t7w8ayaguaaxlhuq
```

Alternatively, users might choose to query directly for `kind:31990` for an event kind. Clients SHOULD be careful doing this and use spam-prevention mechanisms or querying high-quality restricted relays to avoid directing users to malicious handlers.

# Appendix: Client Tag

When publishing events, clients MAY include a `client` tag. Identifying the client or DVM that published the note on behalf of the user. This tag is a tuple of `name`, `address` identifying a handler event, and a relay `hint` for finding the handler event. This has privacy implications for users, so clients SHOULD allow users to opt-out of using this tag.

```jsonc
{
  "kind": 1,
  "tags": [
    ["client", "My Client", "31990:app1-pubkey:<d-identifier>", "wss://relay1"]
  ]
  // other fields...
}
```
