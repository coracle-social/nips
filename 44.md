NIP-44
======

Encrypted Payloads (Versioned)
------------------------------

`optional` `author:paulmillr` `author:staab`

The NIP introduces a new data format for keypair-based encryption. This NIP is versioned to allow multiple algorithm choices to exist simultaneously.

The encrypted payload is encoded as base64 using the character set defined in RFC4648. The first byte of the payload represents the version. The rest depends on the version.

Currently defined encryption algorithms:

- `0x00` - Reserved
- `0x01` - XChaCha20 with same key `sha256(parity + ecdh)` per conversation

# Version 1

Encoding:

- `1` - 1 byte, version
- `nonce` - 24 bytes fetched from a cryptographically secure random source
- `ciphertext` - variable number of bytes until the end

`ciphertext` is created using `xchacha20(key, nonce, plaintext)`. `key` is any private key, either randomly generated or derived from a sender's private key and a recipient's public key.

Example:

- Alice's private key: `5c0c523f52a5b6fad39ed2403092df8cebc36318b39383bca6c00808626fab3a`
- Bob's private key: `4b22aa260e4acb7021e32f38a6cdf4b673c6a277755bfce287e370c924dc936d`

Encrypting the message `hello` from Alice to Bob results in the following base-64 encoded payload:

```
Abd8jOLZT0OAEE6kZ5hI1qd1ZRrVR1W46vRyZCL5
```

# Other Notes

By default in the [libsecp256k1](https://github.com/bitcoin-core/secp256k1) ECDH implementation, the secret is the SHA256 hash of the shared point (both X and Y coordinates). We are using this exact implementation. In NIP-04, unhashed shared point was used. This encryption scheme replaces the one described in NIP-04, which is not secure. It used bad cryptographic building blocks and must not be used.

XChaCha20, being a stream cipher, does not provide integrity guarantees. This encryption scheme should only be used in tandem with a signature or HMAC to verify integrity. Public and private keys should also be checked before validity when deriving a shared key.

# Code Samples

## Javascript

```javascript
import {base64} from '@scure/base'
import {randomBytes} from '@noble/hashes/utils'
import {secp256k1} from '@noble/curves/secp256k1'
import {sha256} from '@noble/hashes/sha256'
import {xchacha20} from '@noble/ciphers/chacha'

const utf8Decoder = new TextDecoder()

const utf8Encoder = new TextEncoder()

export const getSharedSecret = (privkey: string, pubkey: string): Uint8Array =>
  sha256(secp256k1.getSharedSecret(privkey, '02' + pubkey).subarray(1, 33))

export function encrypt(key: Uint8Array, text: string, v = 1) {
  if (v !== 1) {
    throw new Error('NIP44: unknown encryption version')
  }

  const nonce = randomBytes(24)
  const plaintext = utf8Encoder.encode(text)
  const ciphertext = xchacha20(key, nonce, plaintext)

  const payload = new Uint8Array(25 + ciphertext.length)
  payload.set([v], 0)
  payload.set(nonce, 1)
  payload.set(ciphertext, 25)

  return base64.encode(payload)
}

export function decrypt(key: string, payload: string) {
  let data
  try {
    data = base64.decode(payload)
  } catch (e) {
    throw new Error(`NIP44: failed to base64 decode payload: ${e}`)
  }

  if (data[0] !== 1) {
    throw new Error(`NIP44: unknown encryption version: ${data[0]}`)
  }

  const nonce = data.slice(1, 25)
  const ciphertext = data.slice(25)
  const plaintext = xchacha20(key, nonce, ciphertext)

  return utf8Decoder.decode(plaintext)
}
```

## Kotlin

```kotlin
// implementation 'fr.acinq.secp256k1:secp256k1-kmp-jni-android:0.10.1'
// implementation "com.goterl:lazysodium-android:5.1.0@aar"
// implementation "net.java.dev.jna:jna:5.12.1@aar"

fun getSharedSecretNIP44(privKey: ByteArray, pubKey: ByteArray): ByteArray =
  MessageDigest.getInstance("SHA-256").digest(
    Secp256k1.get().pubKeyTweakMul(
      Hex.decode("02") + pubKey,
      privKey
    ).copyOfRange(1, 33)
  )

fun encryptNIP44(msg: String, privKey: ByteArray, pubKey: ByteArray): String {
  val nonce = ByteArray(24).apply {
    SecureRandom.getInstanceStrong().nextBytes(this)
  }

  val cipher = streamXChaCha20Xor(
    message = msg.toByteArray(),
    nonce = nonce,
    key = getSharedSecretNIP44(privKey, pubKey)
  )

  return Base64.getEncoder().encodeToString(
    byteArrayOf(Nip44Version.XChaCha20.code) + nonce + cipher
  )
}

fun decryptNIP44(base64: String, privKey: ByteArray, pubKey: ByteArray): String? {
  val byteArray = Base64.getDecoder().decode(base64)

  require(byteArray[0].toInt() == Nip44Version.XChaCha20.code) { "NIP44: unknown encryption version" }

  return streamXChaCha20Xor(
    message = byteArray.copyOfRange(25, byteArray.size),
    nonce = byteArray.copyOfRange(1, 25),
    key = getSharedSecretNIP44(privKey, pubKey)
  )?.decodeToString()
}

// This method is not exposed in AndroidSodium yet, but it will be in the next version.
fun streamXChaCha20Xor(message: ByteArray, nonce: ByteArray, key: ByteArray): ByteArray? {
  return with (SodiumAndroid()) {
    val resultCipher = ByteArray(message.size)

    val isSuccessful = crypto_stream_chacha20_xor_ic(
      resultCipher,
      message,
      message.size.toLong(),
      nonce.drop(16).toByteArray(), // chacha nonce is just the last 8 bytes.
      0,
      ByteArray(32).apply {
      crypto_core_hchacha20(this, nonce, key, null)
      }
    ) == 0

    if (isSuccessful) resultCipher else null
  }
}

enum class Nip44Version(val code: Int) {
  Reserved(0),
  XChaCha20(1)
}
```

# Test Vectors

```
{
  "valid_sec": [
    {
      "sec1": "0000000000000000000000000000000000000000000000000000000000000001",
      "sec2": "0000000000000000000000000000000000000000000000000000000000000002",
      "shared": "0135da2f8acf7b9e3090939432e47684eb888ea38c2173054d4eedffdf152ca5",
      "nonce": "121f9d60726777642fd82286791ab4d7461c9502ebcbb6e6",
      "plaintext": "a",
      "ciphertext": "ARIfnWByZ3dkL9gihnkatNdGHJUC68u25qM=",
      "note": "sk1 = 1, sk2 = random, 0x02"
    },
    {
      "sec1": "0000000000000000000000000000000000000000000000000000000000000002",
      "sec2": "0000000000000000000000000000000000000000000000000000000000000001",
      "shared": "0135da2f8acf7b9e3090939432e47684eb888ea38c2173054d4eedffdf152ca5",
      "plaintext": "a",
      "ciphertext": "AeCt7jJ8L+WBOTiCSfeXEGXB/C/wgsrSRek=",
      "nonce": "e0adee327c2fe58139388249f7971065c1fc2ff082cad245",
      "note": "sk1 = 1, sk2 = random, 0x02"
    }
  ],
  "valid_pub": [
    {
      "sec1": "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364139",
      "pub2": "0000000000000000000000000000000000000000000000000000000000000002",
      "shared": "a6d6a2f7011cdd1aeef325948f48c6efa40f0ec723ae7f5ac7e3889c43481500",
      "nonce": "f481750e13dfa90b722b7cce0db39d80b0db2e895cc3001a",
      "plaintext": "a",
      "ciphertext": "AfSBdQ4T36kLcit8zg2znYCw2y6JXMMAGjM=",
      "note": "sec1 = n-2, pub2: random, 0x02"
    },
    {
      "sec1": "0000000000000000000000000000000000000000000000000000000000000002",
      "pub2": "1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdeb",
      "shared": "4908464f77dd74e11a9b4e4a3bc2467445bd794e8abcbfafb65a6874f9e25a8f",
      "nonce": "45c484ba2c0397853183adba6922156e09a2ad4e3e6914f2",
      "plaintext": "A Peer-to-Peer Electronic Cash System",
      "ciphertext": "AUXEhLosA5eFMYOtumkiFW4Joq1OPmkU8k/25+3+VDFvOU39qkUDl1aiy8Q+0ozTwbhD57VJoIYayYS++hE=",
      "note": "sec1 = 2, pub2: "
    },
    {
      "sec1": "0000000000000000000000000000000000000000000000000000000000000001",
      "pub2": "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "shared": "132f39a98c31baaddba6525f5d43f2954472097fa15265f45130bfdb70e51def",
      "nonce": "d60de08405cf9bde508147e82224ac6af409c12b9e5492e1",
      "plaintext": "A purely peer-to-peer version of electronic cash would allow online payments to be sent directly from one party to another without going through a financial institution. Digital signatures provide part of the solution, but the main benefits are lost if a trusted third party is still required to prevent double-spending.",
      "ciphertext": "AdYN4IQFz5veUIFH6CIkrGr0CcErnlSS4VdvoQaP2DCB1dIFL72HSriG1aFABcTlu86hrsG0MdOO9rPdVXc3jptMMzqvIN6tJlHPC8GdwFD5Y8BT76xIIOTJR2W0IdrM7++WC/9harEJAdeWHDAC9zNJX81CpCz4fnV1FZ8GxGLC0nUF7NLeUiNYu5WFXQuO9uWMK0pC7tk3XVogk90X6rwq0MQG9ihT7e1elatDy2YGat+VgQlDrz8ZLRw/lvU+QqeXMQgjqn42sMTrimG6NdKfHJSVWkT6SKZYVsuTyU1Iu5Nk0twEV8d11/MPfsMx4i36arzTC9qxE6jftpOoG8f/jwPTSCEpHdZzrb/CHJcpc+zyOW9BZE2ZOmSxYHAE0ustC9zRNbMT3m6LqxIoHq8j+8Ysu+Cwqr4nUNLYq/Q31UMdDg1oamYS17mWIAS7uf2yF5uT5IlG",
      "note": "sec1 == pub2"
    }
  ],
  "invalid": [
    {
      "sec1": "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
      "pub2": "1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
      "plaintext": "a",
      "note": "sec1 higher than curve.n"
    },
    {
      "sec1": "0000000000000000000000000000000000000000000000000000000000000000",
      "pub2": "1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
      "plaintext": "a",
      "note": "sec1 is 0"
    },
    {
      "sec1": "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364139",
      "pub2": "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
      "plaintext": "a",
      "note": "pub2 is invalid, no sqrt, all-ff"
    },
    {
      "sec1": "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141",
      "pub2": "1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
      "plaintext": "a",
      "note": "sec1 == curve.n"
    },
    {
      "sec1": "0000000000000000000000000000000000000000000000000000000000000002",
      "pub2": "1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
      "plaintext": "a",
      "note": "pub2 is invalid, no sqrt"
    }
  ]
}
```
